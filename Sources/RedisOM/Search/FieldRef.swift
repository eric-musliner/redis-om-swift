import RedisOMCore

/// A lightweight reference to an indexed model field used for building RedisSearch queries.
///
/// Each instance represents a
/// path to an indexed field — including nested or collection-based fields —
/// and holds its associated `IndexType` and alias path.
///
/// `FieldRef` instances are automatically generated by the `@Model` macro
/// as static `$` properties on a model type (e.g. `User.$email`).
/// These are then composed through key path chaining and dynamic member
/// lookups to form nested paths.
///
/// ### Example
/// ```swift
/// // Flat field
/// \.$name
///
/// // Nested object field
/// \.$address.$city
///
/// // Deeply nested
/// \.$address.$note.$description
///
/// // Array element field
/// \.$addresses[\.$city]
/// ```
///
/// In all cases, `FieldRef` automatically computes the RedisSearch-safe alias
/// (e.g. `"address__city"`, `"addresses__note__description"`) used for query rendering.
///
/// - SeeAlso: ``IndexType``
/// - Note: `FieldRef` is purely metadata and does not provide access to runtime values.
@dynamicMemberLookup
public struct FieldRef<Value>: Sendable {
    public let indexType: IndexType
    public var aliasPath: [String]

    /// Creates a new field reference.
    ///
    /// - Parameters:
    ///   - indexType: The RedisSearch index type for this field.
    ///   - aliasPath: The hierarchical alias path from the model root.
    public init(indexType: IndexType, aliasPath: [String] = []) {
        self.indexType = indexType
        self.aliasPath = aliasPath
    }

    // MARK: - Dynamic Member Lookups

    /// Allows nested chaining for direct members on a nested type.
    ///
    /// Enables expressions such as `\.$address.$city` to resolve into
    /// a combined alias like `"address__city"`.
    ///
    /// - Parameter key: A key path from the nested model type to a `FieldRef`.
    /// - Returns: A new `FieldRef` with the nested alias appended.
    public subscript<Nested>(dynamicMember key: KeyPath<Value.Type, FieldRef<Nested>>) -> FieldRef<
        Nested
    > {
        let nested = Value.self[keyPath: key]
        return FieldRef<Nested>(
            indexType: nested.indexType,
            aliasPath: aliasPath + nested.aliasPath
        )
    }

    /// Allows nested chaining for optional nested models.
    ///
    /// Enables queries like `\.$address?.$city` or equivalently
    /// `\.$address.$city` when `address` is declared as optional.
    ///
    /// - Parameter key: A key path from the unwrapped type to a `FieldRef`.
    /// - Returns: A new `FieldRef` for the nested optional field.
    public subscript<Nested, Wrapped>(
        dynamicMember key: KeyPath<Wrapped.Type, FieldRef<Nested>>
    ) -> FieldRef<Nested> where Value == Wrapped? {
        let nested = Wrapped.self[keyPath: key]
        return FieldRef<Nested>(
            indexType: nested.indexType,
            aliasPath: aliasPath + nested.aliasPath
        )
    }

    // MARK: - Collections

    /// Accesses an indexed field within a collection element.
    ///
    /// Enables array-style queries like:
    /// ```swift
    /// \.$addresses[\.$city] == "Pittsburg"
    /// ```
    ///
    /// which resolve to the alias `"addresses__city"`.
    ///
    /// - Parameter elementKeyPath: A key path to a `FieldRef` on the element type.
    /// - Returns: A `FieldRef` representing the nested element field.
    public subscript<Element, Nested>(
        _ elementKeyPath: KeyPath<Element.Type, FieldRef<Nested>>
    ) -> FieldRef<Nested> where Value: Collection, Value.Element == Element {
        let nested = Element.self[keyPath: elementKeyPath]
        // Append "[*]" to represent wildcard iteration in JSONPath/alias
        return FieldRef<Nested>(
            indexType: nested.indexType,
            aliasPath: aliasPath + nested.aliasPath
        )
    }

    /// Accesses an indexed field within an optional collection element.
    ///
    /// Supports optional arrays such as `@Index var addresses: [Address]?`.
    ///
    /// - Parameter elementKeyPath: A key path to a `FieldRef` on the element type.
    /// - Returns: A `FieldRef` representing the nested element field.
    public subscript<Element, Nested>(
        _ elementKeyPath: KeyPath<Element.Type, FieldRef<Nested>>
    ) -> FieldRef<Nested> where Value == [Element]? {
        let nested = Element.self[keyPath: elementKeyPath]
        return FieldRef<Nested>(
            indexType: nested.indexType,
            aliasPath: aliasPath + nested.aliasPath
        )
    }

    // MARK: - Computed Properties

    /// The fully-qualified RedisSearch alias for this field.
    ///
    /// Example:
    /// ```swift
    /// ["address", "note", "description"].joined(separator: "__")
    /// // → "address__note__description"
    /// ```
    public var alias: String {
        aliasPath.joined(separator: "__")
    }
}
